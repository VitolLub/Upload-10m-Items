/*! (C) Copyright 2020 LanguageTooler GmbH. All rights reserved. */
class LatexParser{static _getLatexCommandArgument(t,e,n=!1){const s=n?"[":"{",a=n?"]":"}";let r=null,o=0,i=!1;for(;;){const n=t[e];if(null===r){if(n===s)r=e;else if(!LatexParser.WHITESPACE_REGEXP.test(n))return null}else{if(!i)if(n===a){if(0===o)break;o--}else n===s&&o++;i="\\"===n}if(++e>=t.length)return null}return{start:r+1,end:e}}static _formatCommand(t,e,n=[],s=[]){let a=t;for(const t of s){a+=`[${e.substring(t.start,t.end)}]`}for(const t of n){a+=`{${e.substring(t.start,t.end)}}`}return a}static _getCommandSyntax(t,e,n){for(;;){const s=this._formatCommand(t,n,e),a=this.COMMANDS_SYNTAX.get(s);if(a)return a;if(0===e.length)break;e=e.slice(0,-1)}return null}static getCommentTokens(t){const e=[],n=matchAll(t,this.COMMENT_TOKEN_REGEXP);for(const t of n){const n=t.index+t[1].length,s=t.index+t[0].length;e.push({type:"comment",start:n,end:s})}return e}static getSymbolTokens(t){const e=[],n=matchAll(t,this.SYMBOL_TOKEN_REGEXP);for(const s of n){const n=s.index;if(0!==n&&"\\"===t[n-1])continue;const a=s.index+s[0].length,r=s[0];e.push({type:"symbol",start:n,end:a,symbolName:r})}return e}static getSwitchTokens(t,e=this.getCommandTokens(t)){const n=[],s=[];for(const t of e)for(const e of t.arguments)s.push(e.start-1);s.sort(((t,e)=>t-e));const a=matchAll(t,this.SWITCH_TOKEN_START_REGEXP);for(const e of a){const a=e.index+e[1].length;if(-1!==binarySearchIndex(s,a))continue;let r=e.index+e[0].length,o=0;for(;;){if("{"===t[r]&&"\\"!==t[r-1])o++;else if("}"===t[r]&&"\\"!==t[r-1]){if(0===o)break;o--}if(r++,r>=t.length){r=-1;break}}if(-1===r)continue;const i=e[2],u=e.index+e[0].length;n.push({type:"switch",start:a,end:r+1,switchName:i,textStart:u,textEnd:r})}return n}static getFormulaTokens(t,e=this.getCommandTokens(t)){const n=[];let s=matchAll(t,this.FORMULA_TOKEN_DOLLARS_REGEXP);for(const t of s){const e=t.index+t[1].length,s=t.index+t[0].length;n.push({type:"formula",start:e,end:s})}const a=new Map;let r=null;for(const s of e){const e=this._formatCommand(s.commandName,t,s.arguments.slice(0));this.FORMULA_TOKEN_COMMANDS.some((([t])=>t===e))&&a.set(e,s);const o=this.FORMULA_TOKEN_COMMANDS.find((([t,n])=>n===e));if(o){const t=a.get(o[0]);t?(n.push({type:"formula",start:t.start,end:s.end}),a.delete(o[0])):null===r&&(r=s.end)}}null===r||n.some((t=>t.start<=r))||n.push({type:"formula",start:0,end:r});let o=null;return a.forEach((t=>{(null===o||t.start>o)&&(o=t.start)})),null===o||n.some((t=>t.start>=o))||n.push({type:"formula",start:o,end:t.length}),n.sort(((t,e)=>t.start-e.start)),n}static getEquationTokens(t,e=this.getCommandTokens(t)){const n=[];let s=matchAll(t,this.EQUATION_TOKEN_DOLLARS_REGEXP);for(const t of s){const e=t.index+t[1].length,s=t.index+t[0].length;n.push({type:"equation",start:e,end:s})}const a=new Map;let r=null;for(const s of e){const e=this._formatCommand(s.commandName,t,s.arguments.slice(0));this.EQUATION_TOKEN_COMMANDS.some((([t])=>t===e))&&a.set(e,s);const o=this.EQUATION_TOKEN_COMMANDS.find((([t,n])=>n===e));if(o){const t=a.get(o[0]);t?(n.push({type:"equation",start:t.start,end:s.end}),a.delete(o[0])):null===r&&(r=s.end)}}null===r||n.some((t=>t.start<=r))||n.push({type:"equation",start:0,end:r});let o=null;return a.forEach((t=>{(null===o||t.start>o)&&(o=t.start)})),null===o||n.some((t=>t.start>=o))||n.push({type:"equation",start:o,end:t.length}),n.sort(((t,e)=>t.start-e.start)),n}static getMathTokens(t,e=this.getCommandTokens(t)){const n=[...this.getFormulaTokens(t,e),...this.getEquationTokens(t,e)];return n.sort(((t,e)=>t.start-e.start)),n}static getCommandTokens(t){const e=[],n=matchAll(t,this.COMMAND_TOKEN_START_REGEXP);for(const s of n){const n=s.index;let a=n+s[0].length;const r=s[0],o=[],i=[];for(;;){const e=this._getCommandSyntax(r,o,t),n=e?e.argumentsCount:Number.MAX_SAFE_INTEGER;if(o.length<n){const e=this._getLatexCommandArgument(t,a);if(e){o.push(e),a=e.end+1;continue}}const s=this._getLatexCommandArgument(t,a,!0);if(!s)break;i.push(s),a=s.end+1}e.push({type:"command",start:n,end:a,commandName:r,arguments:o,optionalArguments:i})}return e}}LatexParser.WHITESPACE_REGEXP=/^\s/,LatexParser.COMMENT_TOKEN_REGEXP=/(^|[^\\])%.*/gm,LatexParser.SYMBOL_TOKEN_REGEXP=/[~&]/g,LatexParser.SWITCH_TOKEN_START_REGEXP=/(^|[^\\]){\s*(\\[a-z]+)\s*/gim,LatexParser.FORMULA_TOKEN_DOLLARS_REGEXP=/((^|[^\\])(\\\\)*)\$[^]*?[^\\](\\\\)*\$/gm,LatexParser.FORMULA_TOKEN_COMMANDS=[["\\(","\\)"],["\\begin{math}","\\end{math}"]],LatexParser.EQUATION_TOKEN_DOLLARS_REGEXP=/(^|[^\\])\$\$[^]*?[^\\]\$\$/gm,LatexParser.EQUATION_TOKEN_COMMANDS=[["\\[","\\]"],["\\begin{displaymath}","\\end{displaymath}"],["\\begin{equation}","\\end{equation}"],["\\begin{eqnarray}","\\end{eqnarray}"],["\\begin{multline}","\\end{multline}"],["\\begin{multline*}","\\end{multline*}"],["\\begin{gather}","\\end{gather}"],["\\begin{gather*}","\\end{gather*}"],["\\begin{align}","\\end{align}"],["\\begin{align*}","\\end{align*}"],["\\begin{lyxcode}","\\end{lyxcode}"],["\\begin{verbatim}","\\end{verbatim}"],["\\begin{lstlisting}","\\end{lstlisting}"]],LatexParser.COMMAND_TOKEN_START_REGEXP=/\\([^@a-z]|[@a-z]+)\*?/gi,LatexParser.COMMANDS_SYNTAX=new Map([["\\begin{align}",{argumentsCount:1}],["\\begin{align*}",{argumentsCount:1}],["\\begin{array}",{argumentsCount:2}],["\\begin{displaymath}",{argumentsCount:2}],["\\begin{eqnarray}",{argumentsCount:1}],["\\begin{equation}",{argumentsCount:1}],["\\begin{figure}",{argumentsCount:1}],["\\begin{figure*}",{argumentsCount:1}],["\\begin{gather}",{argumentsCount:1}],["\\begin{gather*}",{argumentsCount:1}],["\\begin{list}",{argumentsCount:3}],["\\begin{lstlisting}",{argumentsCount:1}],["\\begin{lyxcode}",{argumentsCount:1}],["\\begin{math}",{argumentsCount:1}],["\\begin{minipage}",{argumentsCount:2}],["\\begin{multline}",{argumentsCount:1}],["\\begin{multline*}",{argumentsCount:1}],["\\begin{table}",{argumentsCount:1}],["\\begin{table*}",{argumentsCount:1}],["\\begin{tabular}",{argumentsCount:2}],["\\begin{verbatim}",{argumentsCount:1}],["\\end",{argumentsCount:1}]]),"undefined"!=typeof module&&(module.exports=LatexParser);